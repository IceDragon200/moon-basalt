require 'basalt/config'
require 'basalt/basaltfile'
require 'basalt/packages/dependecy_solver'
require 'basalt/packages/package_header'

module Basalt
  class Packages
    class Context
      attr_accessor :config
      attr_accessor :basaltfile
      attr_accessor :project_packages_path

      def initialize(config, basaltfile)
        @config = config
        @basaltfile = basaltfile
        @project_packages_path = nil
      end

      def project_package_path(*names)
        File.join(@project_packages_path || projconfig['packages_path'], *names)
      end

      def is_package?(name)
        config['package_paths'].each do |path|
          if Dir.entries(path).include?(name)
            return true
          end
        end
        false
      end

      def find(name)
        config['package_paths'].each do |path|
          pth = File.join(path, name)
          return pth if Dir.exist?(pth)
        end
        nil
      end

      def init_basaltmods
        contents = ''
        contents << "set install_dir: 'packages'\n\n"
        installed_packages do |mod|
          contents << "mod '#{mod}'\n" if is_package?(mod)
        end
        filename = 'Basaltmods'
        filename << '.gen' if File.exist?(filename)
        File.write(filename, contents)
        STDERR.puts '  GENERATED'.light_green + "\t#{filename}"
      end

      def install(name, options = {})
        target = project_package_path(name)
        FileUtils.mkdir_p(project_package_path)

        if File.exist?(target)
          STDERR.puts '  SKIPPED'.light_yellow + "\t#{name}"
        else
          if packagepath = find(name)
            if options[:hard]
              FileUtils.cp_r(packagepath, target)
            else
              FileUtils.ln_sf(packagepath, target)
            end
            STDERR.puts '  INSTALL'.light_green + "\t#{name} (#{packagepath})"
          else
            STDERR.puts '  NOTFOUND'.light_red + "\t#{name}"
          end
        end
      end

      def solve_dependencies(packages, options = {})
        solver = DependecySolver.new(packages)
        solver.solve(options)
      end

      def generate_packages_list(options = {})
        dir = project_package_path

        packagefile = 'package.yml'

        packages = []
        Dir.chdir(dir) do
          entries = Dir.entries('.') - ignore_dirs
          entries.each do |dirname|
            if File.directory?(dirname)
              packagehead = ModuleHead.new
              packagehead.name = dirname
              Dir.chdir(dirname) do
                if File.exist?(packagefile)
                  packagehead.load_from_config_file(packagefile)
                else
                  packagehead.setup_require_contents
                end
              end
              packages << packagehead
            end
          end
        end
        solve_dependencies(packages, options)
      end

      def generate_packages_require(options = {})
        dir = project_package_path

        contents = ''
        contents << "# AutoGenerated by Basalt\n"
        contents << "$: << '#{dir}'\n\n"

        packages = generate_packages_list(options)

        packages.each do |mod|
          contents << mod.require_contents
        end

        filename = 'core/packages.rb'
        File.write(filename, contents)
        STDERR.puts '  GENERATED'.light_green + "\t#{filename}"
      end

      def check_basaltmods
        unless BasaltMods.exist?
          abort "#{BasaltMods.default_filename} is missing"
        end
      end

      def basaltmods_load_context
        @basaltmods ||= begin
          context = BasaltMods.load_project_file
          @project_packages_path = context.install_dir
          FileUtils.mkdir_p(project_package_path)
          context
        end
      end

      def basaltmods_install(options = {})
        check_basaltmods
        context = basaltmods_load_context
        STDERR.puts "Installing #{context.packages.size} packages"
        context.packages.each do |mod|
          install mod.name, options.merge(mod.options)
        end
        generate_packages_require(options)
      end

      def uninstall(name, options = {})
        target = File.join(projconfig['packages_path'], name)

        noop = options.fetch(:noop, false)
        if File.exist?(target) || File.symlink?(target)
          if File.symlink?(target)
            FileUtils.rm(target, noop: noop)
          else
            FileUtils.rm_rf(target, noop: noop)
          end
          STDERR.puts '  UNINSTALL'.light_red + "\t#{name}"
        else
          STDERR.puts '  WARN'.light_yellow + "\t#{name} was not installed"
        end
      end

      def uninstall_multi(packages, options)
        return unless packages.size > 0
        STDERR.puts "Uninstalling #{packages.size} packages"
        packages.each do |m|
          uninstall(m, options)
        end
      end

      def ignore_dirs
        ['.', '..', '.git']
      end

      def available_packages
        config['package_paths'].each_with_object([]) do |path, r|
          (Dir.entries(path) - ignore_dirs).each do |mod|
            fullpath = File.join(path, mod)
            r << [mod, fullpath] if File.directory?(fullpath)
          end
        end
      end

      def installed_packages_a
        path = project_package_path
        if File.exist?(path)
          Dir.entries(path) - ignore_dirs
        else
          []
        end
      end

      def installed_packages
        installed_packages_a.each do |a|
          yield a
        end
      end

      def uninstall_all(options = {})
        uninstall_multi(installed_packages_a, options)
      end

      def uninstall_diff(kept_packages, options = {})
        uninstall_multi(installed_packages_a - kept_packages, options)
      end

      def update(name)
        STDERR.puts 'packages update has not been implemented'
        #(File.join(projconfig["packages_path"], name))
        #STDOUT.puts "  UPDATE\t#{name}"
      end

      def basaltmods_update(options = {})
        check_basaltmods
        context = basaltmods_load_context
        uninstall_diff(context.packages.map(&:name), options)
        basaltmods_install(options)
      end

      def list(name = nil, options = {})
        #
      end

      def list_all(options = {})
        available_packages.each do |mod, fp|
          if options[:verbose]
            puts "#{mod} (#{fp})"
          else
            puts mod
          end
        end
      end

      def repair(name)
        if is_package?(name)
          if File.symlink?(project_package_path(name))
            uninstall(name)
            install(name)
            STDERR.puts "  REPAIRED".light_green + "\t#{name}"
          else
            STDERR.puts "#{name} is not a symlink-ed package, please fix it manually"
          end
        else
          STDERR.puts "#{name} is not a package"
        end
      end

      def repair_all
        STDERR.puts 'Repairing Modules'
        packages_path = projconfig['packages_path']
        (Dir.entries(packages_path) - ['.', '..']).each do |entry|
          repair(entry)
        end
      end
    end
  end
end

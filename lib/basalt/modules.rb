require 'basalt/version'
require 'basalt/config'
require 'basalt/project_config'
require 'basalt/basaltmods'
require 'colorize'
require 'docopt'
require 'fileutils'
require 'ostruct'
require 'yaml'

module Basalt
  module Modules
    class Context
      attr_accessor :config
      attr_accessor :projconfig
      attr_accessor :project_modules_path

      def initialize(config, projconfig)
        @config = config
        @projconfig = projconfig
        @project_modules_path = nil
      end

      def project_module_path(*names)
        File.join(@project_modules_path || projconfig['modules_path'], *names)
      end

      def is_module?(name)
        config['module_paths'].each do |path|
          if Dir.entries(path).include?(name)
            return true
          end
        end
        false
      end

      def find(name)
        config['module_paths'].each do |path|
          pth = File.join(path, name)
          return pth if Dir.exist?(pth)
        end
        nil
      end

      def init_basaltmods
        contents = ''
        contents << "set install_dir: 'modules'\n\n"
        installed_modules do |mod|
          contents << "mod '#{mod}'\n" if is_module?(mod)
        end
        filename = 'Basaltmods'
        filename << '.gen' if File.exist?(filename)
        File.write(filename, contents)
        STDERR.puts '  GENERATED'.light_green + "\t#{filename}"
      end

      def install(name, options = {})
        target = project_module_path(name)
        FileUtils.mkdir_p(project_module_path)

        if File.exist?(target)
          STDERR.puts '  SKIPPED'.light_yellow + "\t#{name}"
        else
          if modulepath = find(name)
            if options[:hard]
              FileUtils.cp_r(modulepath, target)
            else
              FileUtils.ln_sf(modulepath, target)
            end
            STDERR.puts '  INSTALL'.light_green + "\t#{name} (#{modulepath})"
          else
            STDERR.puts '  NOTFOUND'.light_red + "\t#{name}"
          end
        end
      end

      class ModuleHead
        attr_accessor :name
        attr_accessor :config
        attr_accessor :require_contents

        def deps
          (@config && @config[:deps]) || []
        end

        def setup_require_contents
          basaltfilename = '_basalt.rb'

          c = @require_contents = ''
          if @config && (require_name = @config[:require])
            c << "### module(.yml): #{name}/#{require_name}\n"
            if File.exist?(require_name)
              c << File.read(require_name)
            else
              abort "#{name} stated that its :require was '#{require_name}', however the file was not found"
            end
          elsif File.exist?(basaltfilename)
            c << "### module: #{name}/#{basaltfilename}\n"
            c << File.read(basaltfilename)
          elsif File.exist?('load.rb')
            c << "### module: #{name}\n"
            c << "require '#{name}/load'\n"
          end
          c << "\n" unless c.end_with?("\n")
        end

        def load_from_config_file(filename)
          @config = OpenStruct.new(YAML.load_file(filename))
          setup_require_contents
        end
      end

      class DependecySolver
        attr_accessor :modules
        attr_accessor :module_map

        def initialize(modules)
          @modules = modules
          @module_map = modules.each_with_object({}) { |m, h| h[m.name] = m }
        end

        def get_deps(mod, depth = 0, options = {})
          abort 'Dependecy depth too deep (passed 100)' if depth > 100
          mod.deps.map do |depname|
            dep = @module_map.fetch(depname) { abort "Dependecy #{depname} not in list" }
            get_deps(dep, depth + 1, options)
          end.flatten + [mod]
        end

        def solve(options = {})
          modules.map { |mod| get_deps(mod, 0, options) }.flatten.uniq
        end
      end

      def solve_dependencies(modules, options = {})
        solver = DependecySolver.new(modules)
        solver.solve(options)
      end

      def generate_modules_list(options = {})
        dir = project_module_path

        modulefile = 'module.yml'

        modules = []
        Dir.chdir(dir) do
          entries = Dir.entries('.') - ignore_dirs
          entries.each do |dirname|
            if File.directory?(dirname)
              modulehead = ModuleHead.new
              modulehead.name = dirname
              Dir.chdir(dirname) do
                if File.exist?(modulefile)
                  modulehead.load_from_config_file(modulefile)
                else
                  modulehead.setup_require_contents
                end
              end
              modules << modulehead
            end
          end
        end
        solve_dependencies(modules, options)
      end

      def generate_modules_require(options = {})
        dir = project_module_path

        contents = ''
        contents << "# AutoGenerated by Basalt\n"
        contents << "$: << '#{dir}'\n\n"

        modules = generate_modules_list(options)

        modules.each do |mod|
          contents << mod.require_contents
        end

        filename = 'core/modules.rb'
        File.write(filename, contents)
        STDERR.puts '  GENERATED'.light_green + "\t#{filename}"
      end

      def check_basaltmods
        unless BasaltMods.exist?
          abort "#{BasaltMods.default_filename} is missing"
        end
      end

      def basaltmods_load_context
        @basaltmods ||= begin
          context = BasaltMods.load_project_file
          @project_modules_path = context.install_dir
          FileUtils.mkdir_p(project_module_path)
          context
        end
      end

      def basaltmods_install(options = {})
        check_basaltmods
        context = basaltmods_load_context
        STDERR.puts "Installing #{context.modules.size} modules"
        context.modules.each do |mod|
          install mod.name, options.merge(mod.options)
        end
        generate_modules_require(options)
      end

      def uninstall(name, options = {})
        target = File.join(projconfig['modules_path'], name)

        noop = options.fetch(:noop, false)
        if File.exist?(target) || File.symlink?(target)
          if File.symlink?(target)
            FileUtils.rm(target, noop: noop)
          else
            FileUtils.rm_rf(target, noop: noop)
          end
          STDERR.puts '  UNINSTALL'.light_red + "\t#{name}"
        else
          STDERR.puts '  WARN'.light_yellow + "\t#{name} was not installed"
        end
      end

      def uninstall_multi(modules, options)
        return unless modules.size > 0
        STDERR.puts "Uninstalling #{modules.size} modules"
        modules.each do |m|
          uninstall(m, options)
        end
      end

      def ignore_dirs
        ['.', '..', '.git']
      end

      def available_modules
        config['module_paths'].each_with_object([]) do |path, r|
          (Dir.entries(path) - ignore_dirs).each do |mod|
            fullpath = File.join(path, mod)
            r << [mod, fullpath] if File.directory?(fullpath)
          end
        end
      end

      def installed_modules_a
        path = project_module_path
        if File.exist?(path)
          Dir.entries(path) - ignore_dirs
        else
          []
        end
      end

      def installed_modules
        installed_modules_a.each do |a|
          yield a
        end
      end

      def uninstall_all(options = {})
        uninstall_multi(installed_modules_a, options)
      end

      def uninstall_diff(kept_modules, options = {})
        uninstall_multi(installed_modules_a - kept_modules, options)
      end

      def update(name)
        STDERR.puts 'modules update has not been implemented'
        #(File.join(projconfig["modules_path"], name))
        #STDOUT.puts "  UPDATE\t#{name}"
      end

      def basaltmods_update(options = {})
        check_basaltmods
        context = basaltmods_load_context
        uninstall_diff(context.modules.map(&:name), options)
        basaltmods_install(options)
      end

      def list(name = nil, options = {})
        #
      end

      def list_all(options = {})
        available_modules.each do |mod, fp|
          if options[:verbose]
            puts "#{mod} (#{fp})"
          else
            puts mod
          end
        end
      end

      def repair(name)
        if is_module?(name)
          if File.symlink?(project_module_path(name))
            uninstall(name)
            install(name)
            STDERR.puts "  REPAIRED".light_green + "\t#{name}"
          else
            STDERR.puts "#{name} is not a symlink-ed module, please fix it manually"
          end
        else
          STDERR.puts "#{name} is not a module"
        end
      end

      def repair_all
        STDERR.puts 'Repairing Modules'
        modules_path = projconfig['modules_path']
        (Dir.entries(modules_path) - ['.','..']).each do |entry|
          repair(entry)
        end
      end
    end

    DOC =
%Q(usage: %<binname>s modules init
       %<binname>s modules install [NAME...] [-h|--hard]
       %<binname>s modules uninstall NAME...
       %<binname>s modules update [NAME...]
       %<binname>s modules list [NAME...] [-v|--verbose]
       %<binname>s modules repair [NAME...]
)

    def self.run(rootfilename, argv)
      context = Context.new(Config.get, ProjectConfig.get)

      doc = DOC % ({ binname: rootfilename })

      data = Docopt.docopt(doc, argv: argv, version: VERSION, help: true)

      names = data['NAME']

      if data['init']
        context.init_basaltmods
      elsif data['install']
        if names.empty?
          context.basaltmods_install
        else
          names.each do |name|
            context.install(name, hard: data['--hard'] || data['-h'])
          end
        end
      elsif data['uninstall']
        names.each do |name|
          context.uninstall(name)
        end
      elsif data['update']
        if names.empty?
          context.basaltmods_update
        else
          names.each do |name|
            context.update(name)
          end
        end
      elsif data['repair']
        if names.empty?
          context.repair_all
        else
          names.each do |name|
            context.repair(name)
          end
        end
      elsif data['list']
        if names.empty?
          context.list_all(verbose: data['-v'])
        else
          names.each do |name|
            context.list(name, verbose: data['-v'])
          end
        end
      end
    end
  end
end
